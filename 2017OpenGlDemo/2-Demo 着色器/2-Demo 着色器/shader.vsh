//这个告诉编译器我们的目标GLSL编译器版本是3.3.如果编译器不支持这个版本会抛出一个错误。
//#version 330
//layout(location = 0)  前面可以用这个 表示从第0个开始 但个人以后选择用索引选择 自由度更大
//顶点着色器的输入变量用关键字attribute 来限定
//片段着色器的输入变量用关键字varying 来限定
//uniform 类型限定符 表示 共享全局变量
attribute vec3 Position;

/*
 片段着色器 颜色输出
 */
varying lowp vec4 vertexColor;

void main(){
    /*
     ‘gl_Position’ 是一个内置的变量，用来保存同类的（包含X,Y,Z和W元素）顶点位置。光栅器将会查找那个变量并用它作为屏幕空间（跟随一些更多的变换）的位置。将X和Y的值减半意味着让三角形的尺寸变成之前教程中三角形的四分之一。注意我们要设置W的值为1.0，这个对三角形的正确显示极其重要。将物体从3d投影到2d事实上是经过两个独立的阶段完成的。首先，你要使所有的顶点乘以投影变换矩阵（这个会在一些教程中建立），然后，在顶点到达光栅器之前GPU会自动对位置属性进行所谓的‘透视分割’，这意味着它将使用W分量分割gl_Position的所有其他分量元素。在这个教程中我们还没有在顶点着色器中进行任何的投影变换，但是这个‘透视分割’阶段是我们无法禁止的。无论我们从顶点着色器输出什么样的gl_Position值都将被HW使用它的W分量所分割，我们需要注意这个否则我们无法得到我们期望的结果。为了规避‘透视分割’的影响我们设置W为1.0。被1.0分割不会影响顶点位置中其他分量的值从而顶点可以仍然在我们的单位化的盒子模型内部。
     */
    gl_Position = vec4(Position,1.0);
    vertexColor = vec4(1.0,0.0,0.0,1.0);
}




